{
    "docs": [
        {
            "location": "/", 
            "text": "Polynomials.jl\n\n\n\n\nPolynomials.Poly\n\n\nBase.LinAlg.norm\n\n\nBase.chop\n\n\nBase.gcd\n\n\nBase.getindex\n\n\nBase.length\n\n\nBase.truncate\n\n\nPolynomials.coeffs\n\n\nPolynomials.degree\n\n\nPolynomials.poly\n\n\nPolynomials.polyder\n\n\nPolynomials.polyfit\n\n\nPolynomials.polyint\n\n\nPolynomials.polyval\n\n\nPolynomials.roots\n\n\nPolynomials.variable\n\n\n\n\n#\n\n\nPolynomials.Poly\n \n \nType\n.\n\n\n\n\nPoly{T\n:Number}(a::Vector)\n: Construct a polynomial from its coefficients, lowest order first. That is if \np=a_n x^n + ... + a_2 x^2 + a_1 x^1 + a_0\n, we construct this through \nPoly([a_0, a_1, ..., a_n])\n.\n\n\n\n\nExample:\n\n\nPoly([1,0,3,4])    # Poly(1 + 3x^2 + 4x^3)\n\n\n\n\nAn optional variable parameter can be added:\n\n\nPoly([1,2,3], :s)       # Poly(1 + 2s + 3s^2)\n\n\n\n\nThe usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars.\n\n\np = Poly([1,2])        # Poly(1 + 2x)\nq = Poly([1, 0, -1])   # Poly(1 - x^2)\n2p                     # Poly(2 + 4x)\n2+p                    # Poly(3 + 2x)\np - q                  # Poly(2x + x^2)\np*q                    # Poly(1 + 2x - x^2 - 2x^3)\nq/2                    # Poly(0.5 - 0.5x^2)\n\n\n\n\nNote that operations involving polynomials with different variables will error:\n\n\np = Poly([1, 2, 3], :x)\nq = Poly([1, 2, 3], :s)\np + q                  # ERROR: Polynomials must have same variable.\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.norm\n \n \nFunction\n.\n\n\n\n\nnorm(q::Poly, [p])\n: return \np\n norm of polynomial \nq\n\n\n\n\nsource\n\n\n#\n\n\nBase.chop\n \n \nFunction\n.\n\n\nchop(p::Poly{T}; kwargs...)\n chop off leading values which are approximately zero. The tolerances are passed to \nisapprox\n.\n\n\nsource\n\n\n#\n\n\nBase.gcd\n \n \nFunction\n.\n\n\n\n\ngcd(a::Poly, b::Poly)\n: Finds the Greatest Common Denominator of     two polynomials recursively using \nEuclid's     algorithm\n.\n\n\n\n\nExample:\n\n\ngcd(poly([1,1,2]), poly([1,2,3])) # returns (x-1)*(x-2)\n\n\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\n\n\ngetindex(p::Poly, i)\n: If \np=a_n x^n + a_{n-1}x^{n-1} + ... + a_1 x^1 + a_0\n, then \np[i]\n returns \na_i\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.length\n \n \nFunction\n.\n\n\nlegnth(p::Poly)\n: return length of coefficient vector\n\n\nsource\n\n\n#\n\n\nBase.truncate\n \n \nFunction\n.\n\n\ntruncate{T}(p::Poly{T}; reltol = eps(T), abstol = eps(T))\n: returns a polynomial with coefficients a_i truncated to zero if |a_i| \n= reltol*maxabs(a)+abstol\n\n\nsource\n\n\n#\n\n\nPolynomials.coeffs\n \n \nFunction\n.\n\n\ncoeffs(p::Poly)\n: return coefficient vector [a_0, a_1, ..., a_n]\n\n\nsource\n\n\n#\n\n\nPolynomials.degree\n \n \nFunction\n.\n\n\ndegree(p::Poly)\n: return degree of polynomial \np\n\n\nsource\n\n\n#\n\n\nPolynomials.poly\n \n \nFunction\n.\n\n\n\n\npoly(r::AbstractVector)\n: Construct a polynomial from its   roots. This is in contrast to the \nPoly\n constructor, which   constructs a polynomial from its coefficients.\n\n\n\n\nExample:\n\n\n## Represents (x-1)*(x-2)*(x-3)\npoly([1,2,3])     # Poly(-6 + 11x - 6x^2 + x^3)\n\n\n\n\nsource\n\n\n#\n\n\nPolynomials.polyder\n \n \nFunction\n.\n\n\n\n\npolyder(p::Poly)\n: Differentiate the polynomial \np\n term by   term. The order of the resulting polynomial is one lower than the   order of \np\n.\n\n\n\n\nExample:\n\n\npolyder(Poly([1, 3, -1]))   # Poly(3 - 2x)\n\n\n\n\nsource\n\n\n#\n\n\nPolynomials.polyfit\n \n \nFunction\n.\n\n\npolyfit(x, y, n=length(x)-1, sym=:x )\n: Fit a polynomial of degree \nn\n through the points specified by \nx\n and \ny\n where \nn \n= length(x) - 1\n using least squares fit. When \nn=length(x)-1\n (the default), the interpolating polynomial is returned. The optional fourth argument can be used to pass the symbol for the returned polynomial.\n\n\nExample:\n\n\nxs = linspace(0, pi, 5)\nys = map(sin, xs)\npolyfit(xs, ys, 2)\n\n\n\n\nOriginal by \nggggggggg\n\n\nsource\n\n\n#\n\n\nPolynomials.polyint\n \n \nFunction\n.\n\n\n\n\npolyint(p::Poly, k::Number=0)\n: Integrate the polynomial \np\n term   by term, optionally adding constant term \nk\n. The order of the   resulting polynomial is one higher than the order of \np\n.\n\n\n\n\nExamples:\n\n\npolyint(Poly([1, 0, -1]))     # Poly(x - 0.3333333333333333x^3)\npolyint(Poly([1, 0, -1]), 2)  # Poly(2.0 + x - 0.3333333333333333x^3)\n\n\n\n\nsource\n\n\n#\n\n\nPolynomials.polyval\n \n \nFunction\n.\n\n\n\n\npolyval(p::Poly, x::Number)\n: Evaluate the polynomial \np\n at \nx\n using Horner's method.\n\n\n\n\nExample:\n\n\npolyval(Poly([1, 0, -1]), 0.1)  # 0.99\n\n\n\n\nFor \njulia\n version \n0.4\n or greater, the \ncall\n method can be used:\n\n\np = Poly([1,2,3])\np(4)   # 57 = 1 + 2*4 + 3*4^2\n\n\n\n\nsource\n\n\n#\n\n\nPolynomials.roots\n \n \nFunction\n.\n\n\n\n\nroots(p::Poly)\n: Return the roots (zeros) of \np\n, with   multiplicity. The number of roots returned is equal to the order of   \np\n. The returned roots may be real or complex.\n\n\n\n\nExamples:\n\n\nroots(Poly([1, 0, -1]))    # [-1.0, 1.0]\nroots(Poly([1, 0, 1]))     # [0.0+1.0im, 0.0-1.0im]\nroots(Poly([0, 0, 1]))     # [0.0, 0.0]\nroots(poly([1,2,3,4]))     # [1.0,2.0,3.0,4.0]\n\n\n\n\nsource\n\n\n#\n\n\nPolynomials.variable\n \n \nFunction\n.\n\n\nReturn the indeterminate of a polynomial, \nx\n.\n\n\n\n\nvariable(p::Poly)\n: return variable of \np\n as a \nPoly\n object.\n\n\nvariable(T\n:Number, [:x])\n: return poly one(T)*x\n\n\nvariable([var::Symbol])\n: return polynomial 1x over \nFloat64\n.\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#polynomialsjl", 
            "text": "Polynomials.Poly  Base.LinAlg.norm  Base.chop  Base.gcd  Base.getindex  Base.length  Base.truncate  Polynomials.coeffs  Polynomials.degree  Polynomials.poly  Polynomials.polyder  Polynomials.polyfit  Polynomials.polyint  Polynomials.polyval  Polynomials.roots  Polynomials.variable   #  Polynomials.Poly     Type .   Poly{T :Number}(a::Vector) : Construct a polynomial from its coefficients, lowest order first. That is if  p=a_n x^n + ... + a_2 x^2 + a_1 x^1 + a_0 , we construct this through  Poly([a_0, a_1, ..., a_n]) .   Example:  Poly([1,0,3,4])    # Poly(1 + 3x^2 + 4x^3)  An optional variable parameter can be added:  Poly([1,2,3], :s)       # Poly(1 + 2s + 3s^2)  The usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars.  p = Poly([1,2])        # Poly(1 + 2x)\nq = Poly([1, 0, -1])   # Poly(1 - x^2)\n2p                     # Poly(2 + 4x)\n2+p                    # Poly(3 + 2x)\np - q                  # Poly(2x + x^2)\np*q                    # Poly(1 + 2x - x^2 - 2x^3)\nq/2                    # Poly(0.5 - 0.5x^2)  Note that operations involving polynomials with different variables will error:  p = Poly([1, 2, 3], :x)\nq = Poly([1, 2, 3], :s)\np + q                  # ERROR: Polynomials must have same variable.  source  #  Base.LinAlg.norm     Function .   norm(q::Poly, [p]) : return  p  norm of polynomial  q   source  #  Base.chop     Function .  chop(p::Poly{T}; kwargs...)  chop off leading values which are approximately zero. The tolerances are passed to  isapprox .  source  #  Base.gcd     Function .   gcd(a::Poly, b::Poly) : Finds the Greatest Common Denominator of     two polynomials recursively using  Euclid's     algorithm .   Example:  gcd(poly([1,1,2]), poly([1,2,3])) # returns (x-1)*(x-2)  source  #  Base.getindex     Function .   getindex(p::Poly, i) : If  p=a_n x^n + a_{n-1}x^{n-1} + ... + a_1 x^1 + a_0 , then  p[i]  returns  a_i .   source  #  Base.length     Function .  legnth(p::Poly) : return length of coefficient vector  source  #  Base.truncate     Function .  truncate{T}(p::Poly{T}; reltol = eps(T), abstol = eps(T)) : returns a polynomial with coefficients a_i truncated to zero if |a_i|  = reltol*maxabs(a)+abstol  source  #  Polynomials.coeffs     Function .  coeffs(p::Poly) : return coefficient vector [a_0, a_1, ..., a_n]  source  #  Polynomials.degree     Function .  degree(p::Poly) : return degree of polynomial  p  source  #  Polynomials.poly     Function .   poly(r::AbstractVector) : Construct a polynomial from its   roots. This is in contrast to the  Poly  constructor, which   constructs a polynomial from its coefficients.   Example:  ## Represents (x-1)*(x-2)*(x-3)\npoly([1,2,3])     # Poly(-6 + 11x - 6x^2 + x^3)  source  #  Polynomials.polyder     Function .   polyder(p::Poly) : Differentiate the polynomial  p  term by   term. The order of the resulting polynomial is one lower than the   order of  p .   Example:  polyder(Poly([1, 3, -1]))   # Poly(3 - 2x)  source  #  Polynomials.polyfit     Function .  polyfit(x, y, n=length(x)-1, sym=:x ) : Fit a polynomial of degree  n  through the points specified by  x  and  y  where  n  = length(x) - 1  using least squares fit. When  n=length(x)-1  (the default), the interpolating polynomial is returned. The optional fourth argument can be used to pass the symbol for the returned polynomial.  Example:  xs = linspace(0, pi, 5)\nys = map(sin, xs)\npolyfit(xs, ys, 2)  Original by  ggggggggg  source  #  Polynomials.polyint     Function .   polyint(p::Poly, k::Number=0) : Integrate the polynomial  p  term   by term, optionally adding constant term  k . The order of the   resulting polynomial is one higher than the order of  p .   Examples:  polyint(Poly([1, 0, -1]))     # Poly(x - 0.3333333333333333x^3)\npolyint(Poly([1, 0, -1]), 2)  # Poly(2.0 + x - 0.3333333333333333x^3)  source  #  Polynomials.polyval     Function .   polyval(p::Poly, x::Number) : Evaluate the polynomial  p  at  x  using Horner's method.   Example:  polyval(Poly([1, 0, -1]), 0.1)  # 0.99  For  julia  version  0.4  or greater, the  call  method can be used:  p = Poly([1,2,3])\np(4)   # 57 = 1 + 2*4 + 3*4^2  source  #  Polynomials.roots     Function .   roots(p::Poly) : Return the roots (zeros) of  p , with   multiplicity. The number of roots returned is equal to the order of    p . The returned roots may be real or complex.   Examples:  roots(Poly([1, 0, -1]))    # [-1.0, 1.0]\nroots(Poly([1, 0, 1]))     # [0.0+1.0im, 0.0-1.0im]\nroots(Poly([0, 0, 1]))     # [0.0, 0.0]\nroots(poly([1,2,3,4]))     # [1.0,2.0,3.0,4.0]  source  #  Polynomials.variable     Function .  Return the indeterminate of a polynomial,  x .   variable(p::Poly) : return variable of  p  as a  Poly  object.  variable(T :Number, [:x]) : return poly one(T)*x  variable([var::Symbol]) : return polynomial 1x over  Float64 .   source", 
            "title": "Polynomials.jl"
        }
    ]
}